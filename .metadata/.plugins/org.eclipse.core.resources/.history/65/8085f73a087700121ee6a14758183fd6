package collisionalpha.game.objects;

import java.util.ArrayList;

import collisionalpha.game.objects.actions.Attack;
import collisionalpha.game.objects.actions.Goto;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.math.Vector2;

public class Enemy extends GameObject
{
	GameObject device;
	public boolean stunned = false;

	public Enemy(GameObject device, int objectID, float posX, float posY, float mass,
			float friction, float hitWidth, float hitHeight, float hitX,
			float hitY, int[] colliders, boolean isSolid, float touchRadius,
			boolean isTouchable, float drawWidth, float drawHeight,
			Texture sprites, int srcWidth, int srcHeight) {
		super(objectID, posX, posY, mass, friction, hitWidth, hitHeight, hitX, hitY,
				colliders, isSolid, touchRadius, isTouchable, drawWidth, drawHeight,
				sprites, srcWidth, srcHeight);
		this.device = device;
		// TODO Auto-generated constructor stub
	}

	
	@Override
	public void update(float dt, ArrayList<GameObject> objects)
	{
		super.update(dt, objects);
		
		
		this.action_queue.clear();
		if(!stunned)
		{
			this.action_queue.add_action(new Goto(device.get_positionX(), device.get_positionY()));
		}//fi
		else
		{
			if(this.get_vMagnitude() <= 0)
			{
				this.stunned = false;
				this.isSolid = true;
			}
		}
	}
	
	public void stun()
	{
		this.stunned = true;
		this.isSolid = false;
		this.action_queue.clear();
	}
	
	@Override
	public void behavior_collision(GameObject collider)
	{
		float direction = (float)Math.atan2(- this.get_positionY() + collider.get_positionY(),
				- this.get_positionX() + collider.get_positionX());
		
		//Variables for collision.
		float u1x = this.get_velocityX() + (float)(this.get_vMagnitude() * Math.cos(direction));
		float u1y = this.get_velocityY() + (float)(this.get_vMagnitude() * Math.sin(direction));
		float m1 = this.get_mass();
		float m2 = collider.get_mass();
		
		Vector2 v2 = new Vector2();
		
		v2.x = ((u1x * m1)/(m1 + m2))/2;
		v2.y = (u1y * m1)/(m1 + m2)/2;
		float v2angle = v2.angle();
		float v2mag = (float)Math.sqrt(v2.x * v2.x + v2.y * v2.y);
		
		collider.add_movement(this, -1, v2angle, v2mag, 400);
	}//END behavior_collision
}
